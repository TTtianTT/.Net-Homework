<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta name="description" content="SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列将带领大家一起分析其MetaServer的实现机制，本文为第二篇，介绍MetaServer基本功能，比如注册，" />
    <meta property="og:description" content="SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列将带领大家一起分析其MetaServer的实现机制，本文为第二篇，介绍MetaServer基本功能，比如注册，" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>[源码阅读] 阿里SOFA服务注册中心MetaServer(2)  - 罗西的思考 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.svg" type="image/svg+xml" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=jzhy9Oyg5XODXo8F4hsEOQFzKCPYRKZCYc011rNEfQo" />
    <link id="MainCss" rel="stylesheet" href="/skins/lessismoreright/bundle-lessismoreright.min.css?v=OuIR6VZMwNPtTKU-hAnflCXnCLQqA-paR3ll9MErHDM" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/lessismoreright/bundle-lessismoreright-mobile.min.css?v=IYuPjHqtjfD2sYlRY1oohsJ4qxy5ebPfYkgpUs8tqls" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/rossiXYZ/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/rossiXYZ/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/rossiXYZ/wlwmanifest.xml" />
    <script>
        var currentBlogId = 556264;
        var currentBlogApp = 'rossiXYZ';
        var cb_enable_mathjax = true;
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'LessIsMoreRight';
        var visitorUserId = '';
    </script>
        <script>
            var currentPostDateAdded = '2020-10-11 08:37';
        </script>
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=fLUEwRea4WeqlJe_CLnNunLQZl_ViJFLgKpcNDuKptI"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
        TeX: {
        equationNumbers: { autoNumber: ['AMS'], useLabelIds: true },
        extensions: ['extpfeil.js', 'mediawiki-texvc.js'],
        Macros: {bm: "\\boldsymbol"}
        },
        'HTML-CSS': { linebreaks: { automatic: true } },
        SVG: { linebreaks: { automatic: true } }
        });
    </script>
    <script src="https://mathjax.cnblogs.com/2_7_5/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;v=20200504"></script>
    
</head>
<body>
    <a name="top"></a>
    <div id="top_nav" class="navbar">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding">
                    <a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo" /></a>
                </li>
                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>
                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3" />
                        <button type="submit" id="zzk_search_button">
                            <img src="/images/aggsite/search.svg" alt="搜索" />
                        </button>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=oS4PkibyMjZ9rGD5XAcLt99uW_s76Javy2up4dbnZNY" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="javascript:void(0)" onclick="logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signin/?returnUrl=https://www.cnblogs.com/">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    <div id="page_begin_html">
        

    </div>
    <div id="home">
    <div id="header">
        <div id="blogTitle">
            
<div class="title"><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/rossiXYZ/">罗西的思考</a>
</div>
<div class="subtitle">
一手伸向技术，一手伸向生活
</div>

        </div>
        <div id="navigator">
            
<ul id="navList">
    <li id="nav_sitehome"><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
    <li id="nav_myhome">
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/rossiXYZ/">
首页</a>
</li>
    <li id="nav_newpost">

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
    <li id="nav_contact">
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E7%BD%97%E8%A5%BF%E7%9A%84%E6%80%9D%E8%80%83">
联系</a></li>
    <li id="nav_rss">
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/rossiXYZ/rss/">
订阅</a></li>
    <li id="nav_admin">
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>

            <div class="blogStats">
                
<span id="stats_post_count">随笔 - 
89&nbsp;</span>
<span id="stats_article_count">文章 - 
0&nbsp;</span>
<!-- <span id="stats-comment_count"></span> -->
<span id="stats_comment_count">评论 - 
11</span>
            </div>
        </div>
    </div>
    <div id="main">
        <div id="mainContent">
            <div class="forFlow">
                <div id="post_detail">
    <div id="topics">
        <div class="post">
            <h1 class="postTitle">
                
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/rossiXYZ/p/13789353.html">
    <span>[源码阅读] 阿里SOFA服务注册中心MetaServer(2) </span>
    


</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
    <div id="cnblogs_post_description" style="display: none">
        SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列将带领大家一起分析其MetaServer的实现机制，本文为第二篇，介绍MetaServer基本功能，比如注册，存储，通知，续约等。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
    <h1 id="源码阅读-阿里sofa服务注册中心metaserver2">[源码阅读] 阿里SOFA服务注册中心MetaServer(2)</h1>
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#源码阅读-阿里sofa服务注册中心metaserver2">[源码阅读] 阿里SOFA服务注册中心MetaServer(2)</a><ul><li><a href="#0x00-摘要">0x00 摘要</a></li><li><a href="#0x01-metaserver--注册">0x01 MetaServer  注册</a><ul><li><a href="#11-leader入口">1.1 Leader入口</a></li><li><a href="#12-注册">1.2 注册</a></li><li><a href="#13-存储服务">1.3 存储服务</a></li><li><a href="#14-repository服务">1.4 Repository服务</a><ul><li><a href="#141-metarepositoryservice">1.4.1 MetaRepositoryService</a></li><li><a href="#142-put操作">1.4.2 put操作</a></li><li><a href="#143-节点数据存储">1.4.3 节点数据存储</a></li></ul></li><li><a href="#15-jraft实现数据一致性">1.5 jraft实现数据一致性</a></li><li><a href="#16-通知data-session">1.6 通知data, session</a><ul><li><a href="#161-通知操作">1.6.1 通知操作</a></li><li><a href="#162-分发通知消息">1.6.2 分发通知消息</a></li><li><a href="#163-异步处理消息">1.6.3 异步处理消息</a></li><li><a href="#164-另一种产生通知方式">1.6.4 另一种产生通知方式</a></li></ul></li></ul></li><li><a href="#0x02-节点注册">0x02 节点注册</a><ul><li><a href="#21--dataapplication">2.1  DataApplication</a><ul><li><a href="#211-dataconnectionhandler">2.1.1 DataConnectionHandler</a></li><li><a href="#212-datanodehandler">2.1.2 DataNodeHandler</a></li><li><a href="#213-dataconfirmstatusservice">2.1.3 DataConfirmStatusService</a></li><li><a href="#214-消费">2.1.4 消费</a><ul><li><a href="#2141-定时提交节点变更推送任务">2.1.4.1 定时提交节点变更推送任务</a></li><li><a href="#2142-定时异步处理任务">2.1.4.2 定时异步处理任务</a></li><li><a href="#2143-确认步骤">2.1.4.3 确认步骤</a></li><li><a href="#2144-总结消费流程">2.1.4.4 总结消费流程</a></li></ul></li><li><a href="#215-总结">2.1.5 总结</a></li></ul></li><li><a href="#22--sessionnodehandler">2.2  SessionNodeHandler</a></li></ul></li><li><a href="#0x03-注册信息续约">0x03 注册信息续约</a><ul><li><a href="#31-关键类-renewdecorate">3.1 关键类 RenewDecorate</a></li><li><a href="#32-执行路径">3.2 执行路径</a></li><li><a href="#33-renewnodesrequesthandler">3.3 ReNewNodesRequestHandler</a></li></ul></li><li><a href="#0x04-驱除">0x04 驱除</a><ul><li><a href="#41-配置">4.1 配置</a></li><li><a href="#42-驱除">4.2 驱除</a></li></ul></li><li><a href="#0x05-节点列表查询">0x05 节点列表查询</a><ul><li><a href="#51-配置">5.1 配置</a></li><li><a href="#52-响应handler">5.2 响应handler</a></li><li><a href="#53-registry操作">5.3 Registry操作</a></li><li><a href="#54-storeservice操作">5.4 StoreService操作</a></li><li><a href="#55-节点变更时的数据同步">5.5 节点变更时的数据同步</a></li></ul></li><li><a href="#0xff-参考">0xFF 参考</a></li></ul></li></ul></div><p></p>
<h2 id="0x00-摘要">0x00 摘要</h2>
<p>SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列将带领大家一起分析其MetaServer的实现机制，本文为第二篇，介绍MetaServer基本功能，比如注册，存储，通知，续约等。</p>
<h2 id="0x01-metaserver--注册">0x01 MetaServer  注册</h2>
<h3 id="11-leader入口">1.1 Leader入口</h3>
<p>MetaServer 的业务启动是从setLeaderProcessListener开始。</p>
<p>前面提到，MetaServer 集群内部基于 Raft 协议选举和复制，只要不超过 1⁄2 节点宕机，就可以对外服务。</p>
<p>Raft 协议由三个部分组成：</p>
<ul>
<li>领导人选举（Leader Election）</li>
<li>日志复制（Log Replication）</li>
<li>安全性（Safety）</li>
</ul>
<p>如果使用JRaft, 需要实现其状态机，而在MetaServer之中， jraft FSM 的具体实现是 ServiceStateMachine类（后文中会有大量 Raft 相关内容）。</p>
<p>在 raft 选出了MetaServer leader之后，ServiceStateMachine会调用 setLeaderProcessListener，其中又调用到了registerCurrentNode，这样就在MetaServer中注册了当前Meta节点。</p>
<pre><code class="language-java">raftServer.setLeaderProcessListener(new LeaderProcessListener() {
    @Override
    public void startProcess() {
        executorManager.startScheduler();
        PeerId leader = new PeerId(NetUtil.getLocalAddress().getHostAddress(),
            metaServerConfig.getRaftServerPort());
        registerCurrentNode();  //
        raftServer.sendNotify(leader, "leader");
    }
</code></pre>
<p>其运行堆栈如下 ：</p>
<pre><code class="language-java">register:51, MetaServerRegistry (com.alipay.sofa.registry.server.meta.registry)
registerCurrentNode:203, RaftExchanger (com.alipay.sofa.registry.server.meta.remoting)
access$200:56, RaftExchanger (com.alipay.sofa.registry.server.meta.remoting)
startProcess:105, RaftExchanger$1 (com.alipay.sofa.registry.server.meta.remoting)
lambda$onLeaderStart$2:234, ServiceStateMachine (com.alipay.sofa.registry.jraft.bootstrap)
run:-1, 318295790 (com.alipay.sofa.registry.jraft.bootstrap.ServiceStateMachine$$Lambda$191)
call:511, Executors$RunnableAdapter (java.util.concurrent)
run$$$capture:266, FutureTask (java.util.concurrent)
run:-1, FutureTask (java.util.concurrent)
</code></pre>
<h3 id="12-注册">1.2 注册</h3>
<p>注册行为由 Registry 完成。注册接口实现为：</p>
<pre><code class="language-java">public interface Registry&lt;T extends Node&gt; {
    NodeChangeResult setNodes(List&lt;T&gt; nodes);
    NodeChangeResult register(T node);
    void cancel(String connectId, NodeType nodeType);
    void evict();
    void renew(T node, int duration);
    void getOtherDataCenterNodeAndUpdate(NodeType nodeType);
    DataCenterNodes getDataCenterNodes(NodeType nodeType);
    NodeChangeResult getAllNodes(NodeType nodeType);
    void pushNodeListChange(NodeType nodeType);
}
</code></pre>
<p>具体实现举例是：</p>
<pre><code class="language-java">public class MetaServerRegistry implements Registry&lt;Node&gt; {  
    @Override
    public NodeChangeResult register(Node node) {
        StoreService storeService = ServiceFactory.getStoreService(node.getNodeType());
        return storeService.addNode(node);
    }		 
}
</code></pre>
<p>Registry 根据不同的节点类型，获取对应的<code>StoreService</code>完成添加节点服务，这里节点类型就是"META"。</p>
<pre><code class="language-java">node = {MetaNode@6342} "MetaNode{ip=192.168.1.2}"
 nodeType = {Node$NodeType@6369} "META"
 nodeUrl = {URL@6370} "URL{address='192.168.1.2:0'}"
 dataCenter = "DefaultDataCenter"
 name = "192.168.1.2"
 regionId = null
 nodeStatus = {Node$NodeStatus@6373} "INIT"
</code></pre>
<p>storeService 就是从上文 ServiceFactory 介绍的 storeServiceMap 中提取。</p>
<p>比如<code> MetaNode</code>，其对应 storeService 实现为 <code>MetaStoreService</code> ，所以就会用 <code>MetaStoreService</code> 完成存储。</p>
<pre><code class="language-java">storeServiceMap = {HashMap@6394}  size = 3
 {Node$NodeType@6454} "SESSION" -&gt; {SessionStoreService@6455} 
 {Node$NodeType@6369} "META" -&gt; {MetaStoreService@6456} 
 {Node$NodeType@6457} "DATA" -&gt; {DataStoreService@6458} 
</code></pre>
<h3 id="13-存储服务">1.3 存储服务</h3>
<p>Node 然后由 <code>StoreService</code> 存储到 <code>Repository</code> 中，具体举例 <code>MetaStoreService</code> 实现为：</p>
<pre><code class="language-java">public class MetaStoreService implements StoreService&lt;MetaNode&gt; {
    @RaftReference(uniqueId = "metaServer")
    private RepositoryService&lt;String, RenewDecorate&lt;MetaNode&gt;&gt; metaRepositoryService;

    @Override
    public NodeChangeResult addNode(MetaNode metaNode) {
        NodeChangeResult nodeChangeResult;
        String ipAddress = metaNode.getNodeUrl().getIpAddress();
        write.lock();
        try {
            //存放到repository（自动通过jraft同步给集群）
            metaRepositoryService.put(ipAddress, new RenewDecorate(metaNode,
                RenewDecorate.DEFAULT_DURATION_SECS));

            //触发通知(需要通知data/session)
            nodeChangeResult = getNodeChangeResult();
            firePushDataListTask(nodeChangeResult, "addMetaNode");
            firePushSessionListTask(nodeChangeResult, "addMetaNode");
        } finally {
            write.unlock();
        }
        return nodeChangeResult;
    }  
}
</code></pre>
<p>预先把存储流程总结如下：</p>
<pre><code class="language-java">                                                                                      +------------------------------+
                                                     +-----------------------+        |  Map(String, NodeRepository) |
                                                +---&gt;+ metaRepositoryService +-------&gt;+  registry                    |
                                                |    +-----------------------+        +------------------------------+
                                                |
                                                |
                                                |
Register +-------------------+  addNode   +-----+-----------+
+------&gt; | MetaServerRegistry| +--------&gt; | MetaStoreService|
         +-------------------+            +-----+-----------+
                                                |
                                                |
                                                |            +-------------------+     +--------------+       +----------------------+
                                                +----------&gt; |TaskListenerManager+---&gt; |TaskDispatcher| +---&gt; |DataNodeChangePushTask|
                                               sendTaskEvent +-------------------+     +--------------+       +----------------------+

</code></pre>
<p>手机上参见：</p>
<p><img src="https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201009224341528-1176675905.png" alt="" loading="lazy"></p>
<h3 id="14-repository服务">1.4 Repository服务</h3>
<p>Repository算是一个比较经典的概念了，封装数据查询和存储逻辑。定义（来自Martin Fowler的《企业应用架构模式》）：Mediates between the domain and data mapping layers using a collection-like interface for accessing domain objects。</p>
<p>Repository是一个独立的层，介于领域层与数据映射层（数据访问层）之间。它的存在让领域层感觉不到数据访问层的存在，即提供一个类似集合的接口提供给领域层进行领域对象的访问。</p>
<p>Repository可以被认为是仓库管理员，领域层需要什么东西只需告诉仓库管理员，由仓库管理员把东西拿给它，并不需要知道东西实际放在哪。</p>
<p>在这里，Node并没有持久化，而是存储在内存中。于是就要  <u><strong>重点注意</strong>，虽然Repository存储一个Node是很简单的，但是在分布式状态下，如何保证 "在一个Repository中新Node的存储状态"   可以拓展到集群其他节点中？而且能保证 数据一致性呢？</u></p>
<h4 id="141-metarepositoryservice">1.4.1 MetaRepositoryService</h4>
<p><u>MetaRepositoryService 内部的存储是在集群内部由Raft协议来保证数据一致性的</u>。</p>
<p>后端 Repository 可以看作 SOFAJRaft 的状态机，任何对 Map 的操作都会在集群内部，交由 Raft 协议进行同步，从而达到集群内部的一致。从代码中可以看到<code>MetaRepositoryService</code>加上了 <code>RaftService</code> 注解，这就是Raft的部分实现。</p>
<p>为了更好的说明，我们这里提前介绍下 Raft 的两个注解：<code>RaftReference</code> 和 <code>RaftService</code>。</p>
<p>这两个注解可以认为是封装好Raft的，呈现给Registry的接口。<u>RaftReference 对应了客户端代理，RaftService对应着服务端的实现</u>。为什么要这么做？<u><strong>因为需要维护数据一致性，所以必须把单纯的本地调用转换为异步网络调用，这样才能用raft协议保证数据一致性</strong></u>。</p>
<ul>
<li><code>RepositoryService</code> 的具体实现类都加了 <code>@RaftService</code> 注解，这样就说明自己是一个服务端；</li>
<li>凡是 <strong>引用</strong> <code>RepositoryService</code> 的地方，都加了 <code>@RaftReference</code>，这样调用 <code>RepositoryService</code> 的函数就相当于客户端调用到服务端；</li>
<li>凡是加了 <code>@RaftReference</code> 注解的属性，都会被动态代理类替换，其代理实现见 <code>ProxyHandler</code> 类，即将方法调用，封装为 <code>ProcessRequest</code>，通过 RaftClient 发送给 RaftServer。</li>
</ul>
<p>回到<code>MetaRepositoryService</code>代码，具体如下：</p>
<pre><code class="language-java">@RaftService(uniqueId = "metaServer")
public class MetaRepositoryService extends AbstractSnapshotProcess
                          implements RepositoryService&lt;String, RenewDecorate&lt;MetaNode&gt;&gt; {
    @Autowired
    private NodeConfig                                 nodeConfig;
    /**
     * meta node store and version
     */
    private Map&lt;String/*dataCenter*/, NodeRepository&gt; registry          = new ConcurrentHashMap&lt;&gt;();
    private Set&lt;String&gt;                                snapShotFileNames = new HashSet&lt;&gt;();
}
</code></pre>
<h4 id="142-put操作">1.4.2 put操作</h4>
<p>当有新节点 时候，MetaRepositoryService  会进行 put  操作。<u>在具体put函数调用中，实际上是将方法调用，封装为 <code>ProcessRequest</code>，通过 RaftClient 发送给 RaftServer。这样就由 Raft 协议保证了数据一致性</u>。</p>
<pre><code class="language-java">@Override
public RenewDecorate&lt;MetaNode&gt; put(String ipAddress, RenewDecorate&lt;MetaNode&gt; metaNode,
                                   Long currentTimeMillis) {
    try {
        String dataCenter = metaNode.getRenewal().getDataCenter();
        NodeRepository&lt;MetaNode&gt; metaNodeRepository = registry.get(dataCenter);
        if (metaNodeRepository == null) {
            NodeRepository&lt;MetaNode&gt; nodeRepository = new NodeRepository&lt;&gt;(dataCenter,
                new ConcurrentHashMap&lt;&gt;(), currentTimeMillis);
            // put操作实际上是调用到了服务端
            metaNodeRepository = registry.put(dataCenter, nodeRepository); 
            if (metaNodeRepository == null) {
                metaNodeRepository = nodeRepository;
            }
        }
        metaNodeRepository.setVersion(currentTimeMillis);
        Map&lt;String/*ipAddress*/, RenewDecorate&lt;MetaNode&gt;&gt; metaNodes = metaNodeRepository
            .getNodeMap();
        RenewDecorate oldRenewDecorate = metaNodes.get(ipAddress);
        metaNodes.put(ipAddress, metaNode);
    } 
    return metaNode;
}
</code></pre>
<h4 id="143-节点数据存储">1.4.3 节点数据存储</h4>
<p>节点数据的存储，其本质上是存储在内存的哈希表中，其存储结构为：</p>
<pre><code class="language-java">// RepositoryService 底层存储
Map&lt;String/*dataCenter*/, NodeRepository&gt; registry;

// NodeRepository 底层存储
Map&lt;String/*ipAddress*/, RenewDecorate&lt;T&gt;&gt; nodeMap;
</code></pre>
<p>将<code>RenewDecorate</code>存储到该 Map 中，整个节点注册的流程就完成了，至于如何和 Raft 协议进行结合和数据同步，后续会介绍。</p>
<p>节点移除的逻辑类似，将节点信息从该 Map 中删除，也会存储一个变更事件到队列。</p>
<p>最后结果如下 ：</p>
<pre><code class="language-java">this = {MetaRepositoryService@6905} 
 registry = {ConcurrentHashMap@6907}  size = 1
  "DefaultDataCenter" -&gt; {NodeRepository@7251} 
 snapShotFileNames = {HashSet@6904}  size = 1
</code></pre>
<h3 id="15-jraft实现数据一致性">1.5 jraft实现数据一致性</h3>
<p>成员列表数据存储在 Repository 中，Repository 被一致性协议层进行包装，作为 SOFAJRaft 的状态机实现，所有对 Repository 的操作都会同步到其他节点，通过 Registry 来操作存储层。</p>
<p>在同步时候，jraft可以直接调用 MetaRepositoryService，实现内部数据一致性。</p>
<p><u>这里说的是其他节点的同步操作，和上节不同。上节是主动存储节点，这里是被动同步</u>。</p>
<pre><code class="language-java">put:45, MetaRepositoryService (com.alipay.sofa.registry.server.meta.repository.service)
put:31, RepositoryService (com.alipay.sofa.registry.server.meta.repository)
invokeInterface_L3_L:-1, 1412712349 (java.lang.invoke.LambdaForm$DMH)
reinvoke:-1, 1139092036 (java.lang.invoke.LambdaForm$BMH)
invoker:-1, 403463237 (java.lang.invoke.LambdaForm$MH)
invokeExact_MT:-1, 1568507411 (java.lang.invoke.LambdaForm$MH)
invokeWithArguments:627, MethodHandle (java.lang.invoke)
process:123, Processor (com.alipay.sofa.registry.jraft.processor)
onApply:133, ServiceStateMachine (com.alipay.sofa.registry.jraft.bootstrap)
doApplyTasks:534, FSMCallerImpl (com.alipay.sofa.jraft.core)
doCommitted:503, FSMCallerImpl (com.alipay.sofa.jraft.core)
runApplyTask:431, FSMCallerImpl (com.alipay.sofa.jraft.core)
access$100:72, FSMCallerImpl (com.alipay.sofa.jraft.core)
onEvent:147, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
onEvent:141, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
run:137, BatchEventProcessor (com.lmax.disruptor)
run:748, Thread (java.lang)
</code></pre>
<h3 id="16-通知data-session">1.6 通知data, session</h3>
<h4 id="161-通知操作">1.6.1 通知操作</h4>
<p>前文 "1.3 存储服务" 中有 firePushDataListTask，firePushSessionListTask，最终目的是通知所有data/session有metaServer变动，这里把代码再贴出来温习下。</p>
<pre><code class="language-java">public class MetaStoreService implements StoreService&lt;MetaNode&gt; {

    @Override
    public NodeChangeResult addNode(MetaNode metaNode) {

            //存放到repository（自动通过jraft同步给集群）
            metaRepositoryService.put(ipAddress, new RenewDecorate(metaNode,
                RenewDecorate.DEFAULT_DURATION_SECS));

            //触发通知(需要通知data/session)，我们说的就是这里
            nodeChangeResult = getNodeChangeResult();
            firePushDataListTask(nodeChangeResult, "addMetaNode");
            firePushSessionListTask(nodeChangeResult, "addMetaNode");
    }  
}
</code></pre>
<p>firePushDataListTask 和 firePushSessionListTask 进而会往taskListenerManager发送消息，</p>
<pre><code class="language-java">private void firePushDataListTask(NodeChangeResult nodeChangeResult, String nodeOperate) {
    TaskEvent taskEvent = new TaskEvent(nodeChangeResult, TaskType.DATA_NODE_CHANGE_PUSH_TASK);
    taskEvent.setAttribute(Constant.PUSH_NEED_CONFIRM_KEY, false);
    taskEvent.setAttribute(Constant.PUSH_TARGET_TYPE, NodeType.DATA);
    taskEvent.setAttribute(Constant.PUSH_TARGET_OPERATOR_TYPE, nodeOperate);
    taskListenerManager.sendTaskEvent(taskEvent);
}

private void firePushSessionListTask(NodeChangeResult nodeChangeResult, String nodeOperate) {
    //notify all session node
    TaskEvent taskEvent = new TaskEvent(nodeChangeResult, TaskType.DATA_NODE_CHANGE_PUSH_TASK);
    taskEvent.setAttribute(Constant.PUSH_TARGET_TYPE, NodeType.SESSION);
    taskEvent.setAttribute(Constant.PUSH_TARGET_OPERATOR_TYPE, nodeOperate);
    taskListenerManager.sendTaskEvent(taskEvent);
}
</code></pre>
<p>此处是触发通知，于是data 节点, session节点会得到通知。</p>
<p>如何通知data节点, session节点？这里用到了Listener，即调用了 DefaultTaskListenerManager # sendTaskEvent。</p>
<p>堆栈如下 ：</p>
<pre><code class="language-java">sendTaskEvent:45, DefaultTaskListenerManager (com.alipay.sofa.registry.task.listener)
firePushDataListTask:355, MetaStoreService (com.alipay.sofa.registry.server.meta.store)
addNode:127, MetaStoreService (com.alipay.sofa.registry.server.meta.store)
addNode:54, MetaStoreService (com.alipay.sofa.registry.server.meta.store)
register:52, MetaServerRegistry (com.alipay.sofa.registry.server.meta.registry)
registerCurrentNode:203, RaftExchanger (com.alipay.sofa.registry.server.meta.remoting)
access$200:56, RaftExchanger (com.alipay.sofa.registry.server.meta.remoting)
startProcess:105, RaftExchanger$1 (com.alipay.sofa.registry.server.meta.remoting)
lambda$onLeaderStart$2:234, ServiceStateMachine (com.alipay.sofa.registry.jraft.bootstrap)
run:-1, 50941601 (com.alipay.sofa.registry.jraft.bootstrap.ServiceStateMachine$$Lambda$192)
</code></pre>
<h4 id="162-分发通知消息">1.6.2 分发通知消息</h4>
<p>TaskListenerManager 是用来分发各种通知消息的类。</p>
<pre><code class="language-java">public class DefaultTaskListenerManager implements TaskListenerManager {
    @Override
    public void sendTaskEvent(TaskEvent taskEvent) {
        Collection&lt;TaskListener&gt; taskListeners = this.taskListeners.get(taskEvent.getTaskType());
        for (TaskListener taskListener : taskListeners) {
            taskListener.handleEvent(taskEvent);
        }
    }  
}
</code></pre>
<p>在 taskListenerManager.addTaskListener(taskListener); 中注册了很多处理消息的handler，从下面运行变量的文字中可以看出其逻辑意义。</p>
<pre><code class="language-java">this.taskListeners = {ArrayListMultimap@7221} 
 expectedValuesPerKey = 3
 map = {HashMap@7227}  size = 4
  {TaskEvent$TaskType@7235} "RECEIVE_STATUS_CONFIRM_NOTIFY_TASK" -&gt; {ArrayList@7236}  size = 1
   key = {TaskEvent$TaskType@7235} "RECEIVE_STATUS_CONFIRM_NOTIFY_TASK"
   value = {ArrayList@7236}  size = 1
    0 = {ReceiveStatusConfirmNotifyTaskListener@7248} 
  {TaskEvent$TaskType@7237} "PERSISTENCE_DATA_CHANGE_NOTIFY_TASK" -&gt; {ArrayList@7238}  size = 1
   key = {TaskEvent$TaskType@7237} "PERSISTENCE_DATA_CHANGE_NOTIFY_TASK"
   value = {ArrayList@7238}  size = 1
    0 = {PersistenceDataChangeNotifyTaskListener@7254} 
  {TaskEvent$TaskType@7239} "SESSION_NODE_CHANGE_PUSH_TASK" -&gt; {ArrayList@7240}  size = 1
   key = {TaskEvent$TaskType@7239} "SESSION_NODE_CHANGE_PUSH_TASK"
   value = {ArrayList@7240}  size = 1
    0 = {SessionNodeChangePushTaskListener@7252} 
  {TaskEvent$TaskType@7241} "DATA_NODE_CHANGE_PUSH_TASK" -&gt; {ArrayList@7242}  size = 1
   key = {TaskEvent$TaskType@7241} "DATA_NODE_CHANGE_PUSH_TASK"
   value = {ArrayList@7242}  size = 1
    0 = {DataNodeChangePushTaskListener@7250} 
</code></pre>
<p>于是在 sendTaskEvent 之中会调用相关的消息handler来进行处理。</p>
<h4 id="163-异步处理消息">1.6.3 异步处理消息</h4>
<p>具体处理消息，我们举例如下：</p>
<p>DataNodeChangePushTaskListener 就是用来处理DataNode相关消息的类。</p>
<pre><code class="language-java">public class DataNodeChangePushTaskListener implements TaskListener {
  
    private TaskDispatcher&lt;String, MetaServerTask&gt; dataSingleTaskDispatcher;
    private TaskDispatcher&lt;String, MetaServerTask&gt; sessionSingleTaskDispatcher;
  
    @Override
    public void handleEvent(TaskEvent event) {

        NodeType nodeType = (NodeType) event.getAttribute(Constant.PUSH_TARGET_TYPE);
        switch (nodeType) {
            case SESSION:
                MetaServerTask sessionNodeChangePushTask = new DataNodeChangePushTask(
                    NodeType.SESSION, metaServerConfig);
                sessionNodeChangePushTask.setTaskEvent(event);
                sessionSingleTaskDispatcher.dispatch(sessionNodeChangePushTask.getTaskId(),
                    sessionNodeChangePushTask, sessionNodeChangePushTask.getExpiryTime());
                break;
            case DATA:
                MetaServerTask dataNodeChangePushTask = new DataNodeChangePushTask(NodeType.DATA,
                    metaServerConfig);
                dataNodeChangePushTask.setTaskEvent(event);
                dataSingleTaskDispatcher.dispatch(dataNodeChangePushTask.getTaskId(),
                    dataNodeChangePushTask, dataNodeChangePushTask.getExpiryTime());
                break;
            default:
                break;
        }
    }  
} 
</code></pre>
<p>我们可以看到，TaskDispatcher 是一个分发异步消息，随之通过TaskExecutors进行异步操作的类。</p>
<p>假如是DataNode，最后会调用到 DataNodeChangePushTask，其是由 DataNodeSingleTaskProcessor 来执行。</p>
<p>其调用栈如下：</p>
<pre><code class="language-java">pushDataNodes:73, DataNodeServiceImpl (com.alipay.sofa.registry.server.meta.node.impl)
execute:86, DataNodeChangePushTask (com.alipay.sofa.registry.server.meta.task)
process:41, DataNodeSingleTaskProcessor (com.alipay.sofa.registry.server.meta.task.processor)
process:32, DataNodeSingleTaskProcessor (com.alipay.sofa.registry.server.meta.task.processor)
run:136, TaskExecutors$WorkerRunnable (com.alipay.sofa.registry.task.batcher)
run:748, Thread (java.lang)
</code></pre>
<p>具体到 DataNodeChangePushTask 来进行与各个DataNode进行交互的操作。</p>
<pre><code class="language-java">public class DataNodeChangePushTask extends AbstractMetaServerTask {
    private final SessionNodeService sessionNodeService;
    private final DataNodeService    dataNodeService;
    final private MetaServerConfig   metaServerConfig;
    final private NodeType           nodeType;
    private NodeChangeResult         nodeChangeResult;
    private Boolean                  confirm;
    private String                   confirmNodeIp;

    private Map&lt;String, DataNode&gt;    targetNodes;
  
    @Override
    public void execute() {
        switch (nodeType) {
            case SESSION:
                sessionNodeService.pushDataNodes(nodeChangeResult);
                break;
            case DATA:
                dataNodeService
                    .pushDataNodes(nodeChangeResult, targetNodes, confirm, confirmNodeIp);
                break;
            default:
                break;
        }
    }
}  
</code></pre>
<p>以DataNodeServiceImpl为例，可以看到最后调用了 dataNodeExchanger 完成了节点间通讯。</p>
<pre><code class="language-java">public class DataNodeServiceImpl implements DataNodeService {

    @Autowired
    private NodeExchanger         dataNodeExchanger;

    @Autowired
    private StoreService          dataStoreService;

    @Autowired
    private AbstractServerHandler dataConnectionHandler;

    @Override
    public void pushDataNodes(NodeChangeResult nodeChangeResult, Map&lt;String, DataNode&gt; targetNodes,
                              boolean confirm, String confirmNodeIp) {

        if (nodeChangeResult != null) {

            List&lt;Throwable&gt; exceptions = new ArrayList&lt;&gt;();
            NodeConnectManager nodeConnectManager = getNodeConnectManager();

            Collection&lt;InetSocketAddress&gt; connections = nodeConnectManager.getConnections(null);

            // add register confirm
            StoreService storeService = ServiceFactory.getStoreService(NodeType.DATA);
            DataCenterNodes dataCenterNodes = storeService.getDataCenterNodes();
            Map&lt;String, DataNode&gt; registeredNodes = dataCenterNodes.getNodes();

            for (InetSocketAddress address : connections) {
                try {
                    if (targetNodes != null &amp;&amp; !targetNodes.isEmpty()) {
                        if (!targetNodes.keySet().contains(address.getAddress().getHostAddress())) {
                            continue;
                        }
                    } else {
                        if (!registeredNodes.keySet().contains(
                            address.getAddress().getHostAddress())) {
                            continue;
                        }
                    }

                    Request&lt;NodeChangeResult&gt; nodeChangeRequestRequest = new Request&lt;NodeChangeResult&gt;() {
                        @Override
                        public NodeChangeResult getRequestBody() {
                            return nodeChangeResult;
                        }

                        @Override
                        public URL getRequestUrl() {
                            return new URL(address);
                        }
                    };
                    // 节点间通讯
                    Response response = dataNodeExchanger.request(nodeChangeRequestRequest);

                    if (confirm) {
                        Object result = response.getResult();
                        if (result instanceof CommonResponse) {
                            CommonResponse genericResponse = (CommonResponse) result;
                            if (genericResponse.isSuccess()) {
                                confirmStatus(address, confirmNodeIp);
                            } 
                        } 
                    }
                } 
            }
        }
    }
}  
</code></pre>
<h4 id="164-另一种产生通知方式">1.6.4 另一种产生通知方式</h4>
<p><u>ExecutorManager的pushNodeListChange会定期检查，如果有必要，则产生通知</u>。</p>
<p>对应后文的  DataConfirmStatusService 节点变更事件。</p>
<pre><code class="language-java">scheduler.schedule(
        new TimedSupervisorTask("CheckDataNodeListChangePush", scheduler, checkNodeListChangePushExecutor,
                metaServerConfig.getSchedulerCheckNodeListChangePushTimeout(), TimeUnit.SECONDS,
                metaServerConfig.getSchedulerCheckNodeListChangePushExpBackOffBound(),
                () -&gt; metaServerRegistry.pushNodeListChange(NodeType.DATA)),
        metaServerConfig.getSchedulerCheckNodeListChangePushFirstDelay(), TimeUnit.SECONDS);
</code></pre>
<p>其堆栈是：</p>
<pre><code class="language-java">pushNodeListChange:278, DataStoreService (com.alipay.sofa.registry.server.meta.store)
pushNodeListChange:103, MetaServerRegistry (com.alipay.sofa.registry.server.meta.registry)
lambda$startScheduler$4:158, ExecutorManager (com.alipay.sofa.registry.server.meta.executor)
run:-1, 758751909 (com.alipay.sofa.registry.server.meta.executor.ExecutorManager$$Lambda$202)
call:511, Executors$RunnableAdapter (java.util.concurrent)
run$$$capture:266, FutureTask (java.util.concurrent)
run:-1, FutureTask (java.util.concurrent)
</code></pre>
<p>比如</p>
<pre><code class="language-java">public class DataStoreService implements StoreService&lt;DataNode&gt; {
    @Override
    public void pushNodeListChange() {
        NodeOperator&lt;DataNode&gt; fireNode;
        if ((fireNode = dataConfirmStatusService.peekConfirmNode()) != null) {
            NodeChangeResult nodeChangeResult = getNodeChangeResult();
            Map&lt;String, Map&lt;String, DataNode&gt;&gt; map = nodeChangeResult.getNodes();
            Map&lt;String, DataNode&gt; addNodes = map.get(nodeConfig.getLocalDataCenter());
            if (addNodes != null) {
                Map&lt;String, DataNode&gt; previousNodes = dataConfirmStatusService.putExpectNodes(
                    fireNode.getNode(), addNodes);

                if (!previousNodes.isEmpty()) {
                    // 产生通知
                    firePushDataListTask(fireNode, nodeChangeResult, previousNodes, true);
                }
            }
            // 产生通知
            firePushSessionListTask(nodeChangeResult, fireNode.getNodeOperate().toString());
        }
    }  
}  
</code></pre>
<h2 id="0x02-节点注册">0x02 节点注册</h2>
<h3 id="21--dataapplication">2.1  DataApplication</h3>
<h4 id="211-dataconnectionhandler">2.1.1 DataConnectionHandler</h4>
<p>当一个DataApplication启动，首先DataConnectionHandler会响应。</p>
<pre><code class="language-java">connected:40, DataConnectionHandler (com.alipay.sofa.registry.server.meta.remoting.connection)
onEvent:69, ConnectionEventAdapter (com.alipay.sofa.registry.remoting.bolt)
onEvent:44, ConnectionEventListener (com.alipay.remoting)
run:201, ConnectionEventHandler$1 (com.alipay.remoting)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)
</code></pre>
<p>感觉只是设置了一下。</p>
<pre><code class="language-java">public class DataConnectionHandler extends AbstractServerHandler implements NodeConnectManager {
    private Map&lt;String/*connectId*/, InetSocketAddress&gt; connections = new ConcurrentHashMap&lt;&gt;();

    @Override
    public void connected(Channel channel) throws RemotingException {
        super.connected(channel);
        addConnection(channel);
    }
}
</code></pre>
<h4 id="212-datanodehandler">2.1.2 DataNodeHandler</h4>
<p>然后是 DataNodeHandler 会响应。</p>
<pre><code class="language-java">reply:43, DataNodeHandler (com.alipay.sofa.registry.server.meta.remoting.handler)
handleRequest:54, SyncUserProcessorAdapter (com.alipay.sofa.registry.remoting.bolt)
dispatchToUserProcessor:239, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
doProcess:145, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
run:366, RpcRequestProcessor$ProcessTask (com.alipay.remoting.rpc.protocol)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)
</code></pre>
<p>具体代码如下。</p>
<pre><code class="language-java">public class DataNodeHandler extends AbstractServerHandler&lt;DataNode&gt; {
    @Autowired
    private Registry            metaServerRegistry;

    @Override
    public Object reply(Channel channel, DataNode dataNode) {
        NodeChangeResult nodeChangeResult;
        nodeChangeResult = metaServerRegistry.register(dataNode);
        return nodeChangeResult;
    }
}
</code></pre>
<p>接下来是调用Store服务进行添加节点。</p>
<pre><code class="language-java">@Override
public NodeChangeResult register(Node node) {
    StoreService storeService = ServiceFactory.getStoreService(node.getNodeType());
    return storeService.addNode(node);
}
</code></pre>
<p>代码来到 DataStoreService，依然是调用 RepositoryService 来进行节点的注册和存储。</p>
<pre><code class="language-java">public class DataStoreService implements StoreService&lt;DataNode&gt; {
    @Autowired
    private TaskListenerManager                                taskListenerManager;

    @RaftReference(uniqueId = "dataServer")
    private RepositoryService&lt;String, RenewDecorate&lt;DataNode&gt;&gt; dataRepositoryService;

    @RaftReference(uniqueId = "dataServer")
    private NodeConfirmStatusService&lt;DataNode&gt;                 dataConfirmStatusService;

    @Override
    public NodeChangeResult addNode(DataNode dataNode) {
        NodeChangeResult nodeChangeResult;
        String ipAddress = dataNode.getNodeUrl().getIpAddress();
        write.lock();
        try {
            dataRepositoryService.put(ipAddress, new RenewDecorate(dataNode,
                RenewDecorate.DEFAULT_DURATION_SECS));
            renew(dataNode, 30);
            nodeChangeResult = getNodeChangeResult();
            dataConfirmStatusService.putConfirmNode(dataNode, DataOperator.ADD);
        } finally {
            write.unlock();
        }
        return nodeChangeResult;
    }
}
</code></pre>
<p><code>dataConfirmStatusService.putConfirmNode</code> 同时会存储一个变更事件到队列中，主要用于数据推送，消费处理。</p>
<pre><code class="language-java">@Override
public void putConfirmNode(DataNode node, DataOperator nodeOperate) {
	expectNodesOrders.put(new NodeOperator(node, nodeOperate));
}
</code></pre>
<h4 id="213-dataconfirmstatusservice">2.1.3 DataConfirmStatusService</h4>
<p>DataConfirmStatusService 也是注解了RaftService，这说明是一个由 Raft 协议进行同步的存储。</p>
<p>以下的这些存储结构会被同步。</p>
<ul>
<li><code>expectNodesOrders</code> 用来存储节点变更事件；</li>
<li><code>expectNodes</code> 用来存储变更事件需要确认的节点，也就是说 <code>NodeOperator</code> 只有得到了其他节点的确认，才会从 <code>expectNodesOrders</code> 移除；</li>
<li><code>snapShotFileNames</code> 是快照文件名；</li>
</ul>
<pre><code class="language-java">@RaftService(uniqueId = "dataServer")
public class DataConfirmStatusService extends AbstractSnapshotProcess
                                      implements NodeConfirmStatusService&lt;DataNode&gt; {
  
	private ConcurrentHashMap&lt;DataNode/*node*/, Map&lt;String/*ipAddress*/, DataNode&gt;&gt; expectNodes             = new ConcurrentHashMap&lt;&gt;();
	private BlockingQueue&lt;NodeOperator&gt;                                               expectNodesOrders       = new LinkedBlockingQueue();
	private Set&lt;String&gt;   snapShotFileNames 
      
	@Override
  public void putConfirmNode(DataNode node, DataOperator nodeOperate) {
      expectNodesOrders.put(new NodeOperator(node, nodeOperate));
  }    
    
  public NodeOperator&lt;DataNode&gt; peekConfirmNode() {
      return expectNodesOrders.peek();
  }
}  
</code></pre>
<h4 id="214-消费">2.1.4 消费</h4>
<p>事件存储到 BlockingQueue expectNodesOrders 里，哪里去消费呢？ 看源码发现，并不是想象中的使用一个线程阻塞的读。</p>
<p>在<code>ExecutorManager</code>中会启动一个定时任务，轮询该队列有没有数据。即周期性的调用<code>Registry#pushNodeListChange</code>方法，获取队列的头节点并消费。Data 和 Session 各对应一个任务。</p>
<p>具体流程如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/338467/1568256774231-1672888e-de2f-44fd-b9c5-45573f3d4b79.png" alt="push_processor" loading="lazy"></p>
<ol>
<li>首先获取队列（expectNodesOrders）头节点，如果为Null直接返回；</li>
<li>获取当前数据中心的节点列表，并存储到确认表（expectNodes）；</li>
<li>提交节点变更推送任务（firePushXxListTask)；</li>
<li>处理任务，即调用 XxNodeService 的 pushXxxNode 方法，即通过 ConnectionHandler 获取所有的节点连接，发送节点列表；</li>
<li>收到回复后，如果需要确认，则会调用<code>StoreService#confirmNodeStatus</code> 方法，将该节点从expectNodes中移除；</li>
<li>待所有的节点从 expectNodes 中移除，则将此次操作从 expectNodesOrders 移除，处理完毕；</li>
</ol>
<p>具体可以细化如下。</p>
<h5 id="2141-定时提交节点变更推送任务">2.1.4.1 定时提交节点变更推送任务</h5>
<p>本小节对应上面步骤的前三步。</p>
<p>比如关于Data 定时任务如下，里面定期调用了MetaServerRegistry 的 pushNodeListChange函数来处理任务 ：</p>
<pre><code class="language-java">scheduler.schedule(
        new TimedSupervisorTask("CheckDataNodeListChangePush", scheduler, checkNodeListChangePushExecutor,
                metaServerConfig.getSchedulerCheckNodeListChangePushTimeout(), TimeUnit.SECONDS,
                metaServerConfig.getSchedulerCheckNodeListChangePushExpBackOffBound(),
                () -&gt; metaServerRegistry.pushNodeListChange(NodeType.DATA)),
        metaServerConfig.getSchedulerCheckNodeListChangePushFirstDelay(), TimeUnit.SECONDS);
</code></pre>
<p>MetaServerRegistry 中的 pushNodeListChange 定义如下：</p>
<pre><code class="language-java">@Override
public void pushNodeListChange(NodeType nodeType) {
    StoreService storeService = ServiceFactory.getStoreService(nodeType);
    if (storeService != null) {
        storeService.pushNodeListChange();
    }
}
</code></pre>
<p>DataStoreService 这里做了以下工作。</p>
<ol>
<li>首先获取队列（expectNodesOrders）头节点，如果为Null直接返回；</li>
<li>获取当前数据中心的节点列表，并存储到确认表（expectNodes）；</li>
<li>提交节点变更推送任务（firePushXxListTask)；</li>
</ol>
<pre><code class="language-java">@Override
public void pushNodeListChange() {
    NodeOperator&lt;DataNode&gt; fireNode;
    //  首先获取队列（expectNodesOrders）头节点，如果为Null直接返回；
    if ((fireNode = dataConfirmStatusService.peekConfirmNode()) != null) {
        NodeChangeResult nodeChangeResult = getNodeChangeResult();
        Map&lt;String, Map&lt;String, DataNode&gt;&gt; map = nodeChangeResult.getNodes();
        Map&lt;String, DataNode&gt; addNodes = map.get(nodeConfig.getLocalDataCenter());
        if (addNodes != null) {
            // 获取当前数据中心的节点列表，并存储到确认表（expectNodes）；
            Map&lt;String, DataNode&gt; previousNodes = dataConfirmStatusService.putExpectNodes(
                fireNode.getNode(), addNodes);
            // 提交节点变更推送任务（firePushXxListTask)；
            if (!previousNodes.isEmpty()) {
                firePushDataListTask(fireNode, nodeChangeResult, previousNodes, true);
            }
        }
        // 提交节点变更推送任务（firePushXxListTask)；
        firePushSessionListTask(nodeChangeResult, fireNode.getNodeOperate().toString());
    }
}
</code></pre>
<p>这样就把任务提交到了Task任务。</p>
<h5 id="2142-定时异步处理任务">2.1.4.2 定时异步处理任务</h5>
<p>本小节对应上面步骤的后三步。</p>
<p>下面就是定时异步处理任务 。</p>
<ol>
<li>处理任务，即调用 XxNodeService 的 pushXxxNode 方法，即通过 ConnectionHandler 获取所有的节点连接，发送节点列表；</li>
<li>收到回复后，如果需要确认，则会调用<code>StoreService#confirmNodeStatus</code> 方法，将该节点从expectNodes中移除；</li>
<li>待所有的节点从 expectNodes 中移除，则将此次操作从 expectNodesOrders 移除，处理完毕；</li>
</ol>
<pre><code class="language-java">public class DataNodeServiceImpl implements DataNodeService {
    @Override
    public void pushDataNodes(NodeChangeResult nodeChangeResult, Map&lt;String, DataNode&gt; targetNodes,
                              boolean confirm, String confirmNodeIp) {

        if (nodeChangeResult != null) {
            NodeConnectManager nodeConnectManager = getNodeConnectManager();
            Collection&lt;InetSocketAddress&gt; connections = nodeConnectManager.getConnections(null);

            // add register confirm
            StoreService storeService = ServiceFactory.getStoreService(NodeType.DATA);
            DataCenterNodes dataCenterNodes = storeService.getDataCenterNodes();
            Map&lt;String, DataNode&gt; registeredNodes = dataCenterNodes.getNodes();

            // 通过 ConnectionHandler 获取所有的节点连接，发送节点列表；
            for (InetSocketAddress address : connections) {
                try {
                    Request&lt;NodeChangeResult&gt; nodeChangeRequestRequest = new Request&lt;NodeChangeResult&gt;() {
                        @Override
                        public NodeChangeResult getRequestBody() {
                            return nodeChangeResult;
                        }

                        @Override
                        public URL getRequestUrl() {
                            return new URL(address);
                        }
                    };
                    // 发送节点列表；
                    Response response = dataNodeExchanger.request(nodeChangeRequestRequest);

                    if (confirm) {
                        Object result = response.getResult();
                        if (result instanceof CommonResponse) {
                            CommonResponse genericResponse = (CommonResponse) result;
                            if (genericResponse.isSuccess()) {
                             // 收到回复后，如果需要确认，则会调用`StoreService#confirmNodeStatus` 方法，将该节点从expectNodes中移除；
                                confirmStatus(address, confirmNodeIp);
                            }
                        } 
                    }

                } 
            }
        }
    }  
}
</code></pre>
<p>其堆栈如下：</p>
<pre><code class="language-java">pushDataNodes:73, DataNodeServiceImpl (com.alipay.sofa.registry.server.meta.node.impl)
execute:86, DataNodeChangePushTask (com.alipay.sofa.registry.server.meta.task)
process:41, DataNodeSingleTaskProcessor (com.alipay.sofa.registry.server.meta.task.processor)
process:32, DataNodeSingleTaskProcessor (com.alipay.sofa.registry.server.meta.task.processor)
run:136, TaskExecutors$WorkerRunnable (com.alipay.sofa.registry.task.batcher)
run:748, Thread (java.lang)
</code></pre>
<h5 id="2143-确认步骤">2.1.4.3 确认步骤</h5>
<p>进一步细化上文提到的 “确认步骤”</p>
<pre><code class="language-java">private void confirmStatus(InetSocketAddress address, String confirmNodeIp) {
    String ipAddress = address.getAddress().getHostAddress();
    dataStoreService.confirmNodeStatus(ipAddress, confirmNodeIp);
}
</code></pre>
<p>然后是 DataStoreService</p>
<ol>
<li>收到回复后，如果需要确认，则会调用<code>StoreService#confirmNodeStatus</code> 方法，将该节点从expectNodes中移除；</li>
<li>待所有的节点从 expectNodes 中移除，则将此次操作从 expectNodesOrders 移除，处理完毕；</li>
</ol>
<pre><code class="language-java">@Override
public void confirmNodeStatus(String ipAddress, String confirmNodeIp) {
    NodeOperator&lt;DataNode&gt; fireNode = dataConfirmStatusService.peekConfirmNode();
    if (fireNode != null) {
        String fireNodeIp = fireNode.getNode().getIp();
        Map&lt;String/*ipAddress*/, DataNode&gt; waitNotifyNodes = dataConfirmStatusService
            .getExpectNodes(fireNode.getNode());

        if (waitNotifyNodes != null) {
            Set&lt;String&gt; removeIp = getRemoveIp(waitNotifyNodes.keySet());
            removeIp.add(ipAddress);

            // 将该节点从expectNodes中移除；
            waitNotifyNodes = dataConfirmStatusService.removeExpectConfirmNodes(
                fireNode.getNode(), removeIp);

            if (waitNotifyNodes.isEmpty()) {
                //all node be notified,or some disconnect node be evict
                try {
                    // 待所有的节点从 expectNodes 中移除，则将此次操作从 expectNodesOrders 移除，处理完毕；
                    if (null != dataConfirmStatusService
                        .removeExpectNodes((dataConfirmStatusService.pollConfirmNode())
                            .getNode())) {
                        //add init status must notify
                        if (fireNode.getNodeOperate() == DataOperator.ADD) {
                            notifyConfirm(fireNode.getNode());
                        }
                    }
                }
            }
        } else {
            try {
                //wait node not exist,
                dataConfirmStatusService.pollConfirmNode();
            } 
        }
    }
}
</code></pre>
<h5 id="2144-总结消费流程">2.1.4.4 总结消费流程</h5>
<p>对于消费流程，总结如下图：</p>
<pre><code class="language-javascript"> +-------------------+        +-----------+         +------------------------+                                       +----------------+
 |ServiceStateMachine+------&gt; | Processor | +-----&gt; |DataConfirmStatusService|                                       |     loop       |
 +-------------------+        +-----------+         +-----+------------------+                                       v                |
                                                          |                                                   +------+------+         |
                                                          | put                                               |TaskExecutors|         |
                                                          v                                                   +------+------+         |
                                                 +--------+--------+   remo^e                                        |                |
                            +------------------&gt; |expectNodesOrders| &lt;-------+                                       |                |
                            | loop               +--------+--------+         |                                       v                |
                            |                             |                  |                          +------------+--------------+ |
                            |                             | peekConfirmNode  |                          |DataNodeSingleTaskProcessor| |
                            |                             |                  |                          +------------+--------------+ |
                            |                             |                  |                                       |                |
+---------------------------+--------------------+        v                  |                                       |                |
|               ExecutorManager                  |   +----+---+              |                                       v                |
| +--------------------------------------------+ |   |fireNode|              |                            +----------+-----------+    |
| |           TimedSuper^isorTask              | |   +----+---+              |                            |DataNodeChangePushTask|    |
| |  +---------------------------------------+ | |        |                  |                            +----------+-----------+    |
| |  | metaServerRegistry.pushNodeListChange | | |        | putExpectNodes   |                                       |                |
| |  +---------------------------------------+ | |        |                  |                                       |                |
| +--------------------------------------------+ |        v                  |                                       v                |
+------------------------------------------------+ +------+------+   remo^e  |                             +---------+---------+      |
                            ^                      | expectNodes | &lt;---------+------------------&lt;--------+ |DataNodeServiceImpl|      |
                            |                      +------+------+                                       | +---------+---------+      |
                            |                             |                                              |           |                |
                            |                             v                                              |           |                |
                            |               +-------------+--------+                                     |           v                |
                            |               | firePushDataListTask +-----------------------------------&gt; |    +------+-------+        |
                            |               +-------------+--------+ taskListenerManager.sendTaskEvent   |    | StoreService |        |
                            |                             |                                              |    +------+-------+        ^
                            |                             v                                              |           |                |
                            |               +-------------+-----------+                                  |           v                |
                            ^&lt;--------------+ firePushSessionListTask +--------------------------------&gt; |     +-----+-------+        |
                                            +-------------------------+taskListenerManager.sendTaskEvent +-----+confirmStatus|        |
                                                                                                               +-----+-------+        |
                                                                                                                     |                |
                                                                                                                     &gt;----------------+

</code></pre>
<p>手机上参见如下</p>
<p><img src="https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201009224427134-654536082.png" alt="" loading="lazy"></p>
<h4 id="215-总结">2.1.5 总结</h4>
<p>数据节点注册流程总结如下图。</p>
<pre><code class="language-java">                                                                                                       +----------------------------+
                                                              put        +----------------------+      | Map(String, NodeRepository)|
                                                            +----------&gt; |dataRepositoryService +----&gt; | registry                   |
                                                            |            +----------------------+      +----------------------------+
                                                            |
                 register                   addNode         |
+----------------+      +------------------+        +-------+--------+
| DataNodeHandler+-----&gt;+metaServerRegistry+-------&gt;+DataStoreService|                                       TimedSupervisorTask
+----------------+      +------------------+        +-------+--------+
                                                            |            +------------------------+          +------------------+
                                                            +----------&gt; |dataConfirmStatusService| +------&gt; |pushNodeListChange|
                                                          putConfirmNode +------------------------+          +------------------+

</code></pre>
<p>手机上参见如下</p>
<p><img src="https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201009224450673-148329632.png" alt="" loading="lazy"></p>
<h3 id="22--sessionnodehandler">2.2  SessionNodeHandler</h3>
<p>Session节点的注册和Data节点几乎类似。</p>
<p>SessionNodeHandler 定义如下 ：</p>
<pre><code class="language-java">public class SessionNodeHandler extends AbstractServerHandler&lt;SessionNode&gt; {

    private static final Logger LOGGER = LoggerFactory.getLogger(SessionNodeHandler.class);

    @Autowired
    private Registry            metaServerRegistry;

    @Override
    public Object reply(Channel channel, SessionNode sessionNode) {
        NodeChangeResult nodeChangeResult;
        try {
            nodeChangeResult = metaServerRegistry.register(sessionNode);
        } 
        return nodeChangeResult;
    }
}
</code></pre>
<p>然后是进行业务处理的SessionStoreService。</p>
<pre><code class="language-java">public class SessionStoreService implements StoreService&lt;SessionNode&gt; {
  
    @Override
    public NodeChangeResult addNode(SessionNode sessionNode) {

        write.lock();
        try {
            String ipAddress = sessionNode.getNodeUrl().getIpAddress();

            sessionRepositoryService.put(ipAddress, new RenewDecorate(sessionNode,
                RenewDecorate.DEFAULT_DURATION_SECS));

            sessionVersionRepositoryService.checkAndUpdateVersions(nodeConfig.getLocalDataCenter(),
                System.currentTimeMillis());

            renew(sessionNode, 30);
            sessionConfirmStatusService.putConfirmNode(sessionNode, DataOperator.ADD);

        } finally {
            write.unlock();
        }

        return dataStoreService.getNodeChangeResult();
    }
}

</code></pre>
<p>然后是SessionRepositoryService。</p>
<p>注意，这里map的key是ip，这是与Data不一致的地方。</p>
<pre><code class="language-java">@RaftService(uniqueId = "sessionServer")
public class SessionRepositoryService extends AbstractSnapshotProcess
                                                                     implements
                                                                     RepositoryService&lt;String, RenewDecorate&lt;SessionNode&gt;&gt; {
    /**
     * session node store
     */
    private ConcurrentHashMap&lt;String/*ipAddress*/, RenewDecorate&lt;SessionNode&gt;&gt; registry          = new ConcurrentHashMap&lt;&gt;();
  
    @Override
    public RenewDecorate&lt;SessionNode&gt; put(String ipAddress, RenewDecorate&lt;SessionNode&gt; sessionNode,
                                          Long currentTimeMillis) {
        try {
            RenewDecorate oldRenewDecorate = registry.get(ipAddress);
            registry.put(ipAddress, sessionNode);
        }
        return sessionNode;
    }  
}
</code></pre>
<p>由上节可知，DataServer 和 SessionServer 都有处理节点注册请求的 Handler。注册行为由 Registry 完成。</p>
<p>比如 metaServerHandlers。</p>
<pre><code class="language-java">@Bean(name = "metaServerHandlers")
public Collection&lt;AbstractServerHandler&gt; metaServerHandlers() {
    Collection&lt;AbstractServerHandler&gt; list = new ArrayList&lt;&gt;();
    list.add(metaConnectionHandler());
    list.add(getNodesRequestHandler());
    return list;
}
</code></pre>
<h2 id="0x03-注册信息续约">0x03 注册信息续约</h2>
<h3 id="31-关键类-renewdecorate">3.1 关键类 RenewDecorate</h3>
<p>节点注册的时候，节点信息被 <code>RenewDecorate</code> 包装起来了，这个就是实现注册信息续约和驱逐的关键，该类定义 如下：</p>
<pre><code class="language-java">public class RenewDecorate&lt;T&gt; implements Serializable {
    public static final int DEFAULT_DURATION_SECS = 15;
    private T               renewal;  // 节点对象封装
    private long            beginTimestamp; // 注册事件
    private volatile long   lastUpdateTimestamp; // 续约时间
    private long            duration; // 超时时间
  
    public boolean isExpired() {
        return System.currentTimeMillis() &gt; lastUpdateTimestamp + duration;
    }

    public void renew() {
        lastUpdateTimestamp = System.currentTimeMillis() + duration;
    }

    public void renew(long durationSECS) {
        lastUpdateTimestamp = System.currentTimeMillis() + durationSECS * 1000;
    }
}
</code></pre>
<p>该对象为注册节点信息，附加了注册时间、上次续约时间、过期时间。</p>
<p>续约操作就是修改<code>lastUpdateTimestamp</code>，是否过期就是判断<code>System.currentTimeMillis() - lastUpdateTimestamp &gt; duration</code> 是否成立，成立则认为节点超时进行驱逐。</p>
<h3 id="32-执行路径">3.2 执行路径</h3>
<p>可以看到，renew可以从多条执行路径调用。</p>
<p>路径一：</p>
<pre><code class="language-java">renew:70, RenewDecorate (com.alipay.sofa.registry.server.meta.store)
replace:176, DataRepositoryService (com.alipay.sofa.registry.server.meta.repository.service)
replace:45, DataRepositoryService (com.alipay.sofa.registry.server.meta.repository.service)
replace:39, RepositoryService (com.alipay.sofa.registry.server.meta.repository)
invokeInterface_L3_L:-1, 1889671331 (java.lang.invoke.LambdaForm$DMH)
reinvoke:-1, 171310548 (java.lang.invoke.LambdaForm$BMH)
invoker:-1, 559310456 (java.lang.invoke.LambdaForm$MH)
invokeExact_MT:-1, 426124479 (java.lang.invoke.LambdaForm$MH)
invokeWithArguments:627, MethodHandle (java.lang.invoke)
process:123, Processor (com.alipay.sofa.registry.jraft.processor)
onApply:133, ServiceStateMachine (com.alipay.sofa.registry.jraft.bootstrap)
doApplyTasks:534, FSMCallerImpl (com.alipay.sofa.jraft.core)
doCommitted:503, FSMCallerImpl (com.alipay.sofa.jraft.core)
runApplyTask:431, FSMCallerImpl (com.alipay.sofa.jraft.core)
access$100:72, FSMCallerImpl (com.alipay.sofa.jraft.core)
onEvent:147, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
onEvent:141, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
run:137, BatchEventProcessor (com.lmax.disruptor)
run:748, Thread (java.lang)
</code></pre>
<p>路径二：</p>
<pre><code class="language-java">renew:171, DataStoreService (com.alipay.sofa.registry.server.meta.store)
addNode:111, DataStoreService (com.alipay.sofa.registry.server.meta.store)
addNode:60, DataStoreService (com.alipay.sofa.registry.server.meta.store)
register:52, MetaServerRegistry (com.alipay.sofa.registry.server.meta.registry)
reply:43, DataNodeHandler (com.alipay.sofa.registry.server.meta.remoting.handler)
reply:32, DataNodeHandler (com.alipay.sofa.registry.server.meta.remoting.handler)
handleRequest:54, SyncUserProcessorAdapter (com.alipay.sofa.registry.remoting.bolt)
dispatchToUserProcessor:239, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
doProcess:145, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
run:366, RpcRequestProcessor$ProcessTask (com.alipay.remoting.rpc.protocol)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)
</code></pre>
<p>比如在 DataStoreService 之中</p>
<pre><code class="language-java">@Override
public NodeChangeResult addNode(DataNode dataNode) {
    NodeChangeResult nodeChangeResult;
    String ipAddress = dataNode.getNodeUrl().getIpAddress();
    write.lock();
    try {
        dataRepositoryService.put(ipAddress, new RenewDecorate(dataNode,
            RenewDecorate.DEFAULT_DURATION_SECS));
        renew(dataNode, 30);  // 续约 
        nodeChangeResult = getNodeChangeResult();
        dataConfirmStatusService.putConfirmNode(dataNode, DataOperator.ADD);
    } finally {
        write.unlock();
    }
    return nodeChangeResult;
}
</code></pre>
<p>进而调用renew</p>
<pre><code class="language-java">@Override
public void renew(DataNode dataNode, int duration) {
    write.lock();
    try {
        String ipAddress = dataNode.getNodeUrl().getIpAddress();
        RenewDecorate renewer = dataRepositoryService.get(ipAddress);
        if (renewer == null) {
            addNode(dataNode); // 新增 
        } else {
            // 续约
            if (duration &gt; 0) {
                dataRepositoryService.replace(ipAddress, new RenewDecorate(dataNode, duration));
            } else {
                dataRepositoryService.replace(ipAddress, new RenewDecorate(dataNode,
                    RenewDecorate.DEFAULT_DURATION_SECS));
            }

        }
    } finally {
        write.unlock();
    }
}
</code></pre>
<p>因为是Raft对Repository进行数据一致性维护，所以 dataRepositoryService.replace 会被 Proxy 替换，进而来到了ProxyHandler。</p>
<pre><code class="language-java">@Override
public Object invoke(Object proxy, Method method, Object[] args) {
    try {
        ProcessRequest request = new ProcessRequest();
        request.setMethodArgSigs(createParamSignature(method.getParameterTypes()));
        request.setMethodName(method.getName());
        request.setMethodArgs(args);
        request.setServiceName(serviceId);

        if (Processor.getInstance().isLeaderReadMethod(method)) {
            return doInvokeMethod(request);
        }
        return client.sendRequest(request);
    } 
}
</code></pre>
<p>当 Raft  来到 <strong>服务端</strong>，堆栈如下 ：</p>
<pre><code class="language-java">replace:165, DataRepositoryService (com.alipay.sofa.registry.server.meta.repository.service)
replace:45, DataRepositoryService (com.alipay.sofa.registry.server.meta.repository.service)
replace:39, RepositoryService (com.alipay.sofa.registry.server.meta.repository)
invokeInterface_L3_L:-1, 1177311202 (java.lang.invoke.LambdaForm$DMH)
reinvoke:-1, 960369282 (java.lang.invoke.LambdaForm$BMH)
invoker:-1, 198860519 (java.lang.invoke.LambdaForm$MH)
invokeExact_MT:-1, 2035225037 (java.lang.invoke.LambdaForm$MH)
invokeWithArguments:627, MethodHandle (java.lang.invoke)
process:123, Processor (com.alipay.sofa.registry.jraft.processor)
onApply:133, ServiceStateMachine (com.alipay.sofa.registry.jraft.bootstrap)
doApplyTasks:534, FSMCallerImpl (com.alipay.sofa.jraft.core)
doCommitted:503, FSMCallerImpl (com.alipay.sofa.jraft.core)
runApplyTask:431, FSMCallerImpl (com.alipay.sofa.jraft.core)
access$100:72, FSMCallerImpl (com.alipay.sofa.jraft.core)
onEvent:147, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
onEvent:141, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
run:137, BatchEventProcessor (com.lmax.disruptor)
run:748, Thread (java.lang)
</code></pre>
<p>具体renew代码如下，这样就最终完成了更新：</p>
<pre><code class="language-java">@Override
public RenewDecorate&lt;DataNode&gt; replace(String ipAddress, RenewDecorate&lt;DataNode&gt; dataNode,
                                       Long currentTimeMillis) {
    try {
        String dataCenter = dataNode.getRenewal().getDataCenter();
        NodeRepository&lt;DataNode&gt; dataNodeRepository = registry.get(dataCenter);

        if (dataNodeRepository != null) {
            Map&lt;String/*ipAddress*/, RenewDecorate&lt;DataNode&gt;&gt; dataNodes = dataNodeRepository
                .getNodeMap();
            RenewDecorate&lt;DataNode&gt; oldRenewDecorate = dataNodes.get(ipAddress);
            if (oldRenewDecorate != null &amp;&amp; oldRenewDecorate.getRenewal() != null) {
                oldRenewDecorate.setRenewal(dataNode.getRenewal());
                oldRenewDecorate.renew();
            } 
        } 
        return dataNode;
    } 
}
</code></pre>
<p>具体如下图</p>
<pre><code class="language-java">+---------------------------------------+        +---------------------------------------------+
| +------------------------------+      |        |       +----------------------------------+  |
| | +----------------+  registry |Client|        | Server| +----------------------+registry |  |
| | |DataStoreService|           |      |        |       | | DataRepositoryService|         |  |
| | +-----+----------+           |      |        |       | +---------+------------+         |  |
| |       | replace              |      |        |       |           ^  replace             |  |
| |       |                      |      |        |       |           |                      |  |
| |       v                      |      |        |       |    +------+----+                 |  |
| | +-----+--------------------+ |      |        |       |    | Processor |                 |  |
| | |DataRepositoryService stub| |      |        |       |    +------+----+                 |  |
| | +-----+--------------------+ |      |        |       |           ^  onApply             |  |
| |       |                      |      |        |       |           |                      |  |
| |       v                      |      |        |       |   +-------+------+               |  |
| |     +-+---+                  |      |        |       |   | StateMachine |               |  |
| |     |Proxy|                  |      |        |       |   +-------+------+               |  |
| |     +-+---+                  |      |        |       |           ^  process             |  |
| |       | invoke               |      |        |       |           |                      |  |
| |       v                      |      |        |       |           |                      |  |
| |  +----+-------+              |      |        |       |    +------+------+               |  |
| |  |ProxyHandler|              |      |        |       |    |FSMCallerImpl|               |  |
| |  +----+-------+              |      |        |       |    +------+------+               |  |
| |       | sendRequest          |      |        |       |           ^                      |  |
| |       v                      |      |        |       |           |  received            |  |
| |   +---+------+               |      |        |       |           |                      |  |
| |   |RaftClient|               |      |        |       |   +-----------------+            |  |
| |   +----------+               |      | network|       |   |RaftServerHandler|            |  |
| |                              | +-------------------&gt; |   +-----------------+            |  |
| +------------------------------+      |        |       +----------------------------------+  |
|                                       |        |                                             |
+---------------------------------------+        +---------------------------------------------+

</code></pre>
<p>手机上如下</p>
<p><img src="https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201009224518218-1316861681.png" alt="" loading="lazy"></p>
<h3 id="33-renewnodesrequesthandler">3.3 ReNewNodesRequestHandler</h3>
<p>和注册一样，续约请求的处理 Handler 为<code>ReNewNodesRequestHandler</code>，最终交由 StoreService 进行续约操作。另外一点，续约的时候如果没有查询到注册节点，会触发节点注册的操作。</p>
<p>在初始化时候，就设置了ReNew handler。</p>
<pre><code class="language-java">        @Bean(name = "sessionServerHandlers")
        public Collection&lt;AbstractServerHandler&gt; sessionServerHandlers() {
            Collection&lt;AbstractServerHandler&gt; list = new ArrayList&lt;&gt;();
            list.add(sessionConnectionHandler());
            list.add(sessionNodeHandler());
            list.add(renewNodesRequestHandler()); // 注册到Server handler
            list.add(getNodesRequestHandler());
            list.add(fetchProvideDataRequestHandler());
            return list;
        }

        @Bean(name = "dataServerHandlers")
        public Collection&lt;AbstractServerHandler&gt; dataServerHandlers() {
            Collection&lt;AbstractServerHandler&gt; list = new ArrayList&lt;&gt;();
            list.add(dataConnectionHandler());
            list.add(getNodesRequestHandler());
            list.add(dataNodeHandler());
            list.add(renewNodesRequestHandler()); // 注册到Server handler
            list.add(fetchProvideDataRequestHandler());
            return list;
        }

</code></pre>
<p>具体定义如下：</p>
<pre><code class="language-java">public class RenewNodesRequestHandler extends AbstractServerHandler&lt;RenewNodesRequest&gt; {
    @Autowired
    private Registry            metaServerRegistry;

    @Override
    public Object reply(Channel channel, RenewNodesRequest renewNodesRequest) {
        Node renewNode = null;
        renewNode = renewNodesRequest.getNode();
        metaServerRegistry.renew(renewNode, renewNodesRequest.getDuration());
        return null;
    }

    @Override
    public Class interest() {
        return RenewNodesRequest.class;
    }

    @Override
    public HandlerType getType() {
        return HandlerType.PROCESSER;
    }
}
</code></pre>
<h2 id="0x04-驱除">0x04 驱除</h2>
<p>驱出的操作是由定时任务完成，MetaServer 在启动时会启动多个定时任务，详见<code>ExecutorManager#startScheduler</code>，其中一个任务会调用<code>Registry#evict</code>，其实现为遍历存储的 Map, 获得过期的列表，调用<code>StoreService#removeNodes</code>方法，将他们从 <code>Repository</code> 中移除，<u>这个操作也会触发变更通知</u>。该任务默认每3秒执行一次。</p>
<h3 id="41-配置">4.1 配置</h3>
<pre><code class="language-java">public void startScheduler() {
    scheduler.schedule(new TimedSupervisorTask("HeartbeatCheck", scheduler, heartbeatCheckExecutor,
                    metaServerConfig.getSchedulerHeartbeatTimeout(), TimeUnit.SECONDS,
                    metaServerConfig.getSchedulerHeartbeatExpBackOffBound(), () -&gt; metaServerRegistry.evict()),
            metaServerConfig.getSchedulerHeartbeatFirstDelay(), TimeUnit.SECONDS);
}  
</code></pre>
<h3 id="42-驱除">4.2 驱除</h3>
<p>这里就是遍历各种StoreService，获取其中的过期节点，然后进行驱除。</p>
<pre><code class="language-java">public class MetaServerRegistry implements Registry&lt;Node&gt; {
    @Override
    public void evict() {
        for (NodeType nodeType : NodeType.values()) {
            StoreService storeService = ServiceFactory.getStoreService(nodeType);
            if (storeService != null) {
                Collection&lt;Node&gt; expiredNodes = storeService.getExpired();
                if (expiredNodes != null &amp;&amp; !expiredNodes.isEmpty()) {
                    storeService.removeNodes(expiredNodes);
                }
            }
        }
    }  
}    
</code></pre>
<p>具体又会继续调用  DataStoreService。</p>
<pre><code class="language-java">@Override
public void removeNodes(Collection&lt;DataNode&gt; nodes) {
    write.lock();
    try {
        if (nodes != null &amp;&amp; !nodes.isEmpty()) {
            for (DataNode dataNode : nodes) {
                String ipAddress = dataNode.getNodeUrl().getIpAddress();
                RenewDecorate&lt;DataNode&gt; dataNodeRemove = dataRepositoryService
                    .remove(ipAddress);
                if (dataNodeRemove != null) {
                    dataConfirmStatusService.putConfirmNode(dataNode, DataOperator.REMOVE);
                }
            }
        }
    } finally {
        write.unlock();
    }
}
</code></pre>
<p>最后调用到 DataRepositoryService</p>
<pre><code class="language-java">@Override
public RenewDecorate&lt;DataNode&gt; remove(Object key, Long currentTimeMillis) {
    try {
        String ipAddress = (String) key;
        String dataCenter = nodeConfig.getLocalDataCenter();

        NodeRepository&lt;DataNode&gt; dataNodeRepository = registry.get(dataCenter);
        if (dataNodeRepository != null) {
            Map&lt;String/*ipAddress*/, RenewDecorate&lt;DataNode&gt;&gt; dataNodes = dataNodeRepository
                .getNodeMap();
            if (dataNodes != null) {
                RenewDecorate&lt;DataNode&gt; oldRenewDecorate = dataNodes.remove(ipAddress);
                dataNodeRepository.setVersion(currentTimeMillis);
                return oldRenewDecorate;
            }
        }
    } 
}
</code></pre>
<h2 id="0x05-节点列表查询">0x05 节点列表查询</h2>
<p>Data，Meta, Session Server 都提供 <code>getNodesRequestHandler</code> ，用于处理查询当前节点列表的请求，其本质上从底层存储 Repository 读取数据返回。返回的结果的具体结构见 <code>NodeChangeResult</code> 类，包含各个数据中心的节点列表以及版本号。</p>
<pre><code class="language-java">public class NodeChangeResult&lt;T extends Node&gt; implements Serializable {
    private final NodeType                                               nodeType;
    private Map&lt;String/*dataCenter id*/, Map&lt;String /*ipAddress*/, T&gt;&gt; nodes;
    private Long                                                         version;
    private Map&lt;String/*dataCenter*/, Long /*version*/&gt;                dataCenterListVersions;
    /** local dataCenter id */
    private String                                                       localDataCenter;
}
</code></pre>
<h3 id="51-配置">5.1 配置</h3>
<p>Data，Meta，Session Server 都提供 <code>getNodesRequestHandler</code>。具体如下：</p>
<pre><code class="language-java">@Bean(name = "sessionServerHandlers")
public Collection&lt;AbstractServerHandler&gt; sessionServerHandlers() {
    Collection&lt;AbstractServerHandler&gt; list = new ArrayList&lt;&gt;();
    list.add(sessionConnectionHandler());
    list.add(sessionNodeHandler());
    list.add(renewNodesRequestHandler());
    list.add(getNodesRequestHandler()); // 做了配置
    list.add(fetchProvideDataRequestHandler());
    return list;
}

@Bean(name = "dataServerHandlers")
public Collection&lt;AbstractServerHandler&gt; dataServerHandlers() {
    Collection&lt;AbstractServerHandler&gt; list = new ArrayList&lt;&gt;();
    list.add(dataConnectionHandler());
    list.add(getNodesRequestHandler()); // 做了配置
    list.add(dataNodeHandler());
    list.add(renewNodesRequestHandler()); 
    list.add(fetchProvideDataRequestHandler());
    return list;
}

@Bean(name = "metaServerHandlers")
public Collection&lt;AbstractServerHandler&gt; metaServerHandlers() {
    Collection&lt;AbstractServerHandler&gt; list = new ArrayList&lt;&gt;();
    list.add(metaConnectionHandler());
    list.add(getNodesRequestHandler()); // 做了配置
    return list;
}
</code></pre>
<p>getNodesRequestHandler的Bean配置生成如下：</p>
<pre><code class="language-java">@Configuration
public static class MetaServerRemotingConfiguration {
        @Bean
        public AbstractServerHandler getNodesRequestHandler() {
            return new GetNodesRequestHandler();
        }  
}  
</code></pre>
<h3 id="52-响应handler">5.2 响应handler</h3>
<p>NodesRequest 是通过Bolt来响应消息。</p>
<pre><code class="language-java">public class GetNodesRequestHandler extends AbstractServerHandler&lt;GetNodesRequest&gt; {
    @Autowired
    private Registry            metaServerRegistry;

    @Override
    public Object reply(Channel channel, GetNodesRequest getNodesRequest) {
        NodeChangeResult nodeChangeResult;
        try {
            nodeChangeResult = metaServerRegistry.getAllNodes(getNodesRequest.getNodeType());
        } 
        return nodeChangeResult;
    }
}
</code></pre>
<p>堆栈为：</p>
<pre><code class="language-java">getNodeChangeResult:188, MetaStoreService (com.alipay.sofa.registry.server.meta.store)
getAllNodes:96, MetaServerRegistry (com.alipay.sofa.registry.server.meta.registry)
reply:44, GetNodesRequestHandler (com.alipay.sofa.registry.server.meta.remoting.handler)
reply:33, GetNodesRequestHandler (com.alipay.sofa.registry.server.meta.remoting.handler)
handleRequest:54, SyncUserProcessorAdapter (com.alipay.sofa.registry.remoting.bolt)
dispatchToUserProcessor:239, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
doProcess:145, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
run:366, RpcRequestProcessor$ProcessTask (com.alipay.remoting.rpc.protocol)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)
</code></pre>
<p>具体如下图所示：</p>
<pre><code class="language-java">                      +-------------------------+
                      | SyncUserProcessorAdapter|
                      +-----------+-------------+
                                  |
                                  |
                                  v  handleRequest
                       +----------+-----------+
                       |GetNodesRequestHandler|
                       +----------+-----------+
                                  |
                                  |
                                  v  getAllNodes
                         +--------+---------+
                         |MetaServerRegistry|
                         +--------+---------+
                                  |
                                  |
                                  v  getNodeChangeResult
                          +-------+--------+
                          |MetaStoreService|
                          +----+------+----+
                               |      |
                   +-----------+      +------------+
                   |                               |
      getNodeMap   v                               v  getNodeMap
+------------------+-----------+        +----------+-------------------+
|dataCenter, metaNodeRepository|  ...   |dataCenter, metaNodeRepository|
+------------------------------+        +------------------------------+

</code></pre>
<p>我们可以再具体深入下。</p>
<h3 id="53-registry操作">5.3 Registry操作</h3>
<p>Registry 只是简单调用StoreService。</p>
<pre><code class="language-java">public class MetaServerRegistry implements Registry&lt;Node&gt; {
    @Override
    public NodeChangeResult getAllNodes(NodeType nodeType) {
        StoreService storeService = ServiceFactory.getStoreService(nodeType);
        return storeService.getNodeChangeResult();
    }  
}  
</code></pre>
<h3 id="54-storeservice操作">5.4 StoreService操作</h3>
<p>Service 会遍历数据中心，获取对应的Node列表以及version，最终返回。</p>
<pre><code class="language-java">public class MetaStoreService implements StoreService&lt;MetaNode&gt; {
    @Override
    public NodeChangeResult getNodeChangeResult() {

        NodeChangeResult nodeChangeResult = new NodeChangeResult(NodeType.META);
        String localDataCenter = nodeConfig.getLocalDataCenter();
        Map&lt;String/*dataCenter*/, NodeRepository&gt; metaRepositoryMap = metaRepositoryService.getNodeRepositories();
        ConcurrentHashMap&lt;String/*dataCenter*/, Map&lt;String/*ipAddress*/, MetaNode&gt;&gt; pushNodes = new ConcurrentHashMap&lt;&gt;();
        Map&lt;String/*dataCenter*/, Long&gt; versionMap = new ConcurrentHashMap&lt;&gt;();

        metaRepositoryMap.forEach((dataCenter, metaNodeRepository) -&gt; {

            if (localDataCenter.equalsIgnoreCase(dataCenter)) {
                nodeChangeResult.setVersion(metaNodeRepository.getVersion());
            }
            versionMap.put(dataCenter, metaNodeRepository.getVersion());

            Map&lt;String, RenewDecorate&lt;MetaNode&gt;&gt; dataMap = metaNodeRepository.getNodeMap();
            Map&lt;String, MetaNode&gt; newMap = new ConcurrentHashMap&lt;&gt;();
            dataMap.forEach((ip, dataNode) -&gt; newMap.put(ip, dataNode.getRenewal()));
            pushNodes.put(dataCenter, newMap);
        });

        nodeChangeResult.setLocalDataCenter(localDataCenter);
        nodeChangeResult.setNodes(pushNodes);
        nodeChangeResult.setDataCenterListVersions(versionMap);
        return nodeChangeResult;
    } 
}  
</code></pre>
<p>最后结果是：</p>
<pre><code class="language-java">nodeChangeResult = 
 nodeType = {Node$NodeType@7190} "DATA"
 nodes = {ConcurrentHashMap@8267}  size = 1
  "DefaultDataCenter" -&gt; {ConcurrentHashMap@8276}  size = 0
   key = "DefaultDataCenter"
   value = {ConcurrentHashMap@8276}  size = 0
 version = {Long@8268} 1601126414990
 dataCenterListVersions = {ConcurrentHashMap@8269}  size = 1
  "DefaultDataCenter" -&gt; {Long@8268} 1601126414990
   key = "DefaultDataCenter"
   value = {Long@8268} 1601126414990
 localDataCenter = "DefaultDataCenter"
  value = {char[17]@8280} 
  hash = 761435552
</code></pre>
<h3 id="55-节点变更时的数据同步">5.5 节点变更时的数据同步</h3>
<p>MetaServer 会通过网络连接感知到新节点上线或者下线，所有的 DataServer 中运行着一个定时刷新连接的任务 ConnectionRefreshTask，该任务定时去轮询 MetaServer，获取数据节点的信息。需要注意的是，除了 DataServer 主动去 MetaServer 拉取节点信息外，MetaServer 也会主动发送 NodeChangeResult 请求到各个节点，通知节点信息发生变化，推拉获取信息的最终效果是一致的。</p>
<p>本文提到了很多Raft相关信息，下篇文章就具体探究下究竟MetaServer是如何使用 Raft。</p>
<h2 id="0xff-参考">0xFF 参考</h2>
<p><a href="https://www.sofastack.tech/blog/sofa-registry-metaserver-function-introduction/">服务注册中心 MetaServer 功能介绍和实现剖析 | SOFARegistry 解析</a></p>
<p><a href="https://www.sofastack.tech/blog/sofa-registry-dataserver-smooth-expansion-contraction/">服务注册中心如何实现 DataServer 平滑扩缩容 | SOFARegistry 解析</a></p>
<p><a href="https://www.sofastack.tech/blog/sofa-registry-data-consistency/">服务注册中心数据一致性方案分析 | SOFARegistry 解析</a></p>
<p><a href="https://www.sofastack.tech/blog/sofa-registry-service-offline-notification/">服务注册中心如何实现秒级服务上下线通知 | SOFARegistry 解析</a></p>
<p><a href="https://www.sofastack.tech/blog/sofa-registry-session-storage/">服务注册中心 Session 存储策略 | SOFARegistry 解析</a></p>
<p><a href="https://www.sofastack.tech/blog/sofa-registry-data-fragmentation-synchronization-scheme/">服务注册中心数据分片和同步方案详解 | SOFARegistry 解析</a></p>
<p><a href="https://www.sofastack.tech/blog/sofa-registry-service-discovery-optimization/">服务注册中心 SOFARegistry 解析 | 服务发现优化之路</a></p>
<p><a href="https://www.sofastack.tech/blog/sofa-registry-introduction/">海量数据下的注册中心 - SOFARegistry 架构介绍</a></p>
<p><a href="https://www.sofastack.tech/projects/sofa-registry/server-quick-start/">服务端部署</a></p>
<p><a href="https://www.sofastack.tech/projects/sofa-registry/client-quick-start/">客户端使用</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/125573685">全面理解Raft协议</a></p>
<p><a href="https://blog.csdn.net/ff00yo/article/details/89212859">详解蚂蚁金服 SOFAJRaft | 生产级高性能 Java 实现</a></p>
<p><a href="https://www.cnblogs.com/luozhiyun/p/13150808.html">从JRaft来看Raft协议实现细节</a></p>
<p><a href="https://www.cnblogs.com/luozhiyun/p/11627092.html">SOFAJRaft—初次使用</a></p>
<p><a href="https://www.bookstack.cn/read/sofa-jraft/3.md">JRaft 用户指南 &amp; API 详解</a></p>
<p><a href="https://www.cnblogs.com/bonelee/p/6228998.html">怎样打造一个分布式数据库——rocksDB, raft, mvcc，本质上是为了解决跨数据中心的复制</a></p>
<p><a href="http://www.bubuko.com/infodetail-3451565.html">sofa-bolt源码阅读(5)-日志</a></p>
<p><a href="https://www.cnblogs.com/mindwind/p/5231986.html">Raft 为什么是更易理解的分布式一致性算法</a></p>
<p><a href="https://segmentfault.com/a/1190000022397988">SOFAJRaft 源码分析一（启动流程和节点变化）</a></p>
<p><a href="https://www.sofastack.tech/blog/sofa-jraft-algorithm-storage-module-deep-dive/">SOFAJRaft 实现原理 - 生产级 Raft 算法库存储模块剖析</a></p>
<p><a href="https://www.sofastack.tech/projects/sofa-registry/client-quick-start/">客户端使用</a></p>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2020-10-11 08:37</span>&nbsp;
<a href="https://www.cnblogs.com/rossiXYZ/">罗西的思考</a>&nbsp;
阅读(<span id="post_view_count">21</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=13789353" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(13789353);return false;">收藏</a></div>
        </div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 556264, cb_blogApp = 'rossiXYZ', cb_blogUserGuid = '3d1961d5-3b13-4975-9d25-08d753a9a8fd';
    var cb_entryId = 13789353, cb_entryCreatedDate = '2020-10-11 08:37', cb_postType = 1;
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id='div-gpt-ad-1592365906576-0' style='width: 300px; height: 250px;'></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id='div-gpt-ad-1592366332455-0' style='width: 468px; height: 60px;'></div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverT2();
        deliverC1C2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>    </div>
</div>
            </div>
        </div>

        <div id="sideBar">
            <div id="sideBarMain">
                
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

<div id="sidebar_ad"></div>
                <div id="calendar"><div id="blog-calendar" style="display:none"></div></div>                
                <script>loadBlogDefaultCalendar();</script>
                <div id="leftcontentcontainer">
                    <!-- begin:SingleColumn -->
                    <div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
                    <!-- end:  SingleColumn -->
                </div>
            </div>
        </div>
        <div class="clear"></div>
    </div>
    <div class="clear"></div>
    <div id="footer">
        <!--done-->
Copyright &copy; 2020 罗西的思考
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>

    </div>
</div>

    
</body>
</html>
